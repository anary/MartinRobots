using Domain.Services;
using MediatR;

namespace Application.RobotCommands;

//TODO: refactor to Infrastructure layer
public interface IRobotRepository
{
    Task<Domain.Robot.Robot> GetRobotAsync(Guid id);
    Task SaveRobotAsync(Domain.Robot.Robot robot);
}

public sealed class ProcessBobotInstructionsCommandHandler : IRequestHandler<ProcessRobotInstructionsCommand, string>
{
    private readonly IRobotRepository _robotrepository;
    private readonly MarsGridService _marsGridService;

    public ProcessBobotInstructionsCommandHandler(IRobotRepository robotrepository, MarsGridService marsGridService)
    {
        _robotrepository = robotrepository;
        _marsGridService = marsGridService;
    }

    public async Task<string> Handle(ProcessRobotInstructionsCommand request, CancellationToken cancellationToken)
    {
        // create a new robot aggregate
        var robot = Domain.Robot.Robot.Land(Guid.NewGuid(), request.StartX, request.StartY, request.StartOrientation);

        // execute the instructions by calling the methods on the robot aggregate
        foreach (var instruction in request.Instructions)
        {
            switch (instruction)
            {
                case 'L':
                    robot.TurnLeft();
                    break;
                case 'R':
                    robot.TurnRight();
                    break;
                case 'F':
                    robot.MoveForward(_marsGridService);
                    break;
                default:
                    throw new InvalidOperationException($"Unknown instruction: {instruction}");
            }
        }
        // persist the new events generated by robot aggregate
        await _robotrepository.SaveRobotAsync(robot);

        // return the final state of the robot as a string
        return robot.ToString();
    }
}
