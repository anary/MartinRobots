using Domain.Abstractions.Persistence;
using Domain.Robots;
using Domain.Services;
using MediatR;

namespace Application.RobotCommands;

public sealed class ProcessBobotInstructionsCommandHandler : IRequestHandler<ProcessRobotInstructionsCommand, string>
{
    private readonly IRobotRepository _robotrepository;
    private readonly MarsGridService _marsGridService;

    public ProcessBobotInstructionsCommandHandler(IRobotRepository robotrepository, MarsGridService marsGridService)
    {
        _robotrepository = robotrepository;
        _marsGridService = marsGridService;
    }

    public async Task<string> Handle(ProcessRobotInstructionsCommand request, CancellationToken cancellationToken)
    {
        // create a new robot aggregate
        var robot = Robot.Land(Guid.NewGuid(), request.StartX, request.StartY, request.StartOrientation);

        // execute the instructions by calling the methods on the robot aggregate
        foreach (var instruction in request.Instructions)
        {
            switch (instruction)
            {
                case 'L':
                    robot.TurnLeft();
                    break;
                case 'R':
                    robot.TurnRight();
                    break;
                case 'F':
                    robot.MoveForward(_marsGridService);
                    break;
                default:
                    throw new InvalidOperationException($"Unknown instruction: {instruction}");
            }
        }
        // persist the new events generated by robot aggregate
        await _robotrepository.SaveRobotAsync(robot, cancellationToken);

        // return the final state of the robot as a string
        return robot.ToString();
    }
}
